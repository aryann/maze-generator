#!/usr/bin/env python
import cStringIO
import random
import os


_RIGHT_WALL = 0b01
_BOTTOM_WALL = 0b10
_BOTH_WALLS = _RIGHT_WALL | _BOTTOM_WALL


class _Groups(object):

    def __init__(self, num_members):
        self.groups = range(num_members)

    def _FindGroupId(self, member_id):
        if not (0 <= member_id < len(self.groups)):
            raise ValueError(
                'member_id must be in the range [0, {0}]; received: {1}'
                .format(len(self.groups) - 1, member_id))

        while self.groups[member_id] != member_id:
            member_id = self.groups[member_id]

        # TODO: At some point, we should do some path compression here.
        return member_id

    def Unionize(self, member_id_a, member_id_b):
        group_a = self._FindGroupId(member_id_a)
        group_b = self._FindGroupId(member_id_b)
        if group_a < group_b:
            self.groups[group_b] = group_a
        elif group_b < group_a:
            self.groups[group_a] = group_b

    def InSameGroup(self, member_id_a, member_id_b):
        return self._FindGroupId(member_id_a) == self._FindGroupId(member_id_b)


class Maze(object):

    def __init__(self, n):
        if n < 1:
            raise ValueError(
                'the dimensions of the maze must be positive; received: {0}'
                .format(n))

        self.maze = []
        self.n = n
        for _ in xrange(n):
            self.maze.append([_BOTH_WALLS] * n)

        # Just to make sure _RamoveWall works, let's run it 10 times.
        for _ in range(10):
            self._RemoveWall()

    def _RemoveWall(self):
        row = random.randint(0, self.n - 1)
        col = random.randint(0, self.n - 1)

        # We don't want to remove walls that are part of the right or
        # bottom border. We also want to make sure that the
        # probability of an internal wall being removed is uniform
        # among all walls.

        # If the cell is neither in the bottom-most row nor in the
        # right-most column, we can go ahead and pick between removing
        # either a right wall or a bottom wall.
        if row != self.n - 1 and col != self.n - 1:
            wall_to_remove = random.choice([_RIGHT_WALL, _BOTTOM_WALL])

        # If the cell is the exit cell, then the right and bottom walls
        # are both part of the border, so we should not remove them.
        elif row == self.n - 1 and col == self.n - 1:
            wall_to_remove = None

        # If the cell is in the bottom row, then either remove a right
        # wall or do nothing.
        elif row == self.n - 1:
            wall_to_remove = random.choice([_RIGHT_WALL, None])

        # Similar to the above condition, except for the right-most column.
        elif col == self.n - 1:
            wall_to_remove = random.choice([_BOTTOM_WALL, None])

        if wall_to_remove:
            self.maze[row][col] = self.maze[row][col] & ~wall_to_remove

    def __str__(self):
        buf = cStringIO.StringIO()
        for _ in self.maze[0]:
            buf.write('+')
            buf.write('--')
        buf.write('+')
        buf.write(os.linesep)
        for row in self.maze:
            buf.write('|')
            for cell in row:
                buf.write('  ')
                if cell & _RIGHT_WALL:
                    buf.write('|')
                else:
                    buf.write(' ')
            buf.write(os.linesep)
            buf.write('+')
            for cell in row:
                if cell & _BOTTOM_WALL:
                    buf.write('--')
                else:
                    buf.write('  ')
                buf.write('+')
            buf.write(os.linesep)
        return buf.getvalue()


if __name__ == '__main__':
    maze = Maze(10)
    print maze
